# 改善Java程序的151个建议

[TOC]

#### 第一章：Java 开发中通用的方法和准则

1. 不要在常量和变量中出现易混淆的字母

2. 莫让常量蜕变成变量

3. 三元操作符的类型务必一致

4. 避免带有变长参数的方法重载

5. 别让 null 值和空值威胁到变长方法
   - 得让编译器知道 null 值是什么类型的，编译即可顺利通过，也减少了错误的发生

6. 覆写变长方法也循规蹈矩
   - 参数列表必须与重写方法相同：即，不仅仅是类型、数量，还包括显示形式，都要与父类相同。

7. 警惕自增的陷阱

8. 不要让旧语法困扰你

9. 少用静态导入
   - 静态导入的作用是把 Math 等类的常量引入到本类中，这会使程序更加简单，但如果滥用静态导入的话则会使程序更难阅读。因为静态导入后就不用在代码中再写类名了，所以容易混淆。
   - 静态导入一定要遵循两个规则：**1、不使用*通配符，除非是导入静态常量类。2、方法名是具有明确。清晰表象意义的工具类**

10. 不要在本类中覆盖静态导入的变量和方法
  - 编译器的 “最短路径” 原则：如果能在本类中查到变量、常量、方法。就不会到其他包或父类、接口中查找。因此，如果报变更一个被静态导入的方法，最好办法是在原始类中重构，而不是在本类中覆盖。

11. 养成良好习惯、显示声明UID
    - 显示声明 serivalVersionUID 可以避免对象不一致（在生存者的 Person 类变更之后，未变更的消费端版本仍可以反序列化），实现版本向上兼容的功能，提高代码的健壮性。

12. 避免用序列化类在构造函数中为不变量赋值
    - 在序列化类中，不要使用构造函数为 final 变量赋值。因为反序列化时构造函数不会执行。当使用构造函数赋值时，修改之后，在反序列化时，查看数据流中的类文件描述信息，发现是 final 变量，需要重新计算，于是引用类中的 name 值并没有赋值，不能引用，所以不再初始化，保持原值状态，所以会导致业务异常。而使用直接赋值就不会：`public final String name="me"`

13. 避免为 final 变量复杂赋值

    - 反序列化时 final 变量在以下情况不会被重新赋值
      - 通过构造函数为 final 变量赋值
      - 通过方法返回值赋值
      - final 修饰的属性不是基本类型

14. 使用序列化类的的私有方法巧妙地解决部分属性持久化的问题

    1. 在bonus 前加上 transient 关键字

       不是一个好方法，加上 transient 关键字就以为着该类失去了分布式部署的功能，因此否定。

    2. 新增业务对象

       - 增加一个类专门为计税系统服务，只有姓名和基本工资两个属性。符合开闭原则，而且对原系统也没有入侵性。但不是最优方法。

    3. 请求端过滤

       - HR 系统中的 Salary 类安全性居然让外系统承担，设计严重失职。

    4. 变更传输契约

       - 比如使用 xml 传输，或者重建一个 Web Service 服务，可以，但成本过高

    **优秀解决方法**：

    ```java
    public class Person implements Serializable{
      private static final long serialVersionUID = 60407L;
      //名字
      private String name;
      //薪水
      private transient Salary salary;
      
      public Person(String _name,Salary _salary){
        name=_name;
        salary=_salary;
      }
      //序列化委托方法
      private void writeObject(java.io.ObjectOutputStream out) throws IOException{
        out.defalutWriteObject();
        out.writeInt(salary。getBasePay());
      }
      //反序列化时委托方法
      private void readObject(java.io.ObjectInputStream in)throws IOException ,NotFoundException{
        in.defalutReadObject();
        salary = new Salary(in.readInt(),0);
      } 
    }
    ```

15. break 万万不可忘

16. 易变业务使用脚本语言编写**（未读）**

17. 慎用动态编译**（未读）**

18. 避免 instanceof 非预期结果

    - 操作符的左右操作数必须有继承或实现关系，否则编译会失败
    - 若左操作数是 null ，结果就直接返回 false ，不在运算右操作数是什么类。

19. 断言绝对不是鸡肋**（在学完 JUnit 测试之后可以再看）**

20. 不要只替换一个类

    - 在常量类修改重新编译之后，Client 引用类如果没有重新编译而直接运行的话，常量仍然是旧常量，因为 Client 类编译时，字节码就写上了 ”150“ 这个常量，而不是一个地址引用，因此只要不重新编译 Client 类，输出还是照旧。原因：**对于 final 修饰的类，编译器认为它是不稳定态，在编译时建立的则是引用关系，如果 Client 类引入的常量（不用 final 修饰的）是一个类或者实例，即使不重新编译也会输出新值。**

#### 第二章、基本类型

1. 用偶判断，不用奇判断

   - Java中的取余算法，实现的模拟代码如下：`return div-div/divisor*divisor`
   - 所以不要`i%2 ==1?"奇":"偶"`,而应该`i%2==0?"偶":"奇"`

2. 用整数类型处理货币

   - 因为计算机中浮点数有可能是不准确的，他只能无限接近准确值，而不能完全精确。（这是由浮点数的存储规则所决定的）解决问题的方法：
     - 使用 BigDecimal
     - 使用整型（先扩大100倍，并转为整型，展示时缩小 100 倍

3. 不要让类型默默转换

   - 使用主动声明方法减少不必要的 Bug
     - `long dis2 = 1L * LIGTH_SPEED *60 * 8`
     - 不加 1L 则会出现 dis2 是负数的情形，因为Java是先运算后进行类型转换的。

4. 边界，边界，还是边界

   - 输入 2147483647 ，再加1000，就超出 int 范围了，结果就是负数的了，所以就小于判断条件了。边界情况要切记注意。不可只依赖于前端的验证代码，因为前端验证代码对于高手无济于事。

5. 不要让四舍五入亏了一方

   - 目前Java提供7中舍入方式，要根据不同的场景，慎重选择不同的舍入模式，提高项目的精确度，减少算法损失。最好的例子就是银行家算法。(RoundingMode.HALF_DOWN)

6. 提防包装类型的 null 值

   - 记住一点：**包装类型参与运算时，要做 null 值校验**

   - ```java
     for(Integer i : list){
       count += (i!=null)?i:0;
     }
     return count;
     ```

7. 谨慎包装类型的大小比较

   ```java
   Integer i =new Integer(2);
   Integer j =new Integer(2);//不相等

   Integer i=2;
   Integer j=2;//相等 
   ```

   - 在 Java 中 "=="是用来判断两个操作数是否有相等关系的，如果是基本类型则判断值是否相等，如果是对象则判断是否是一个对象的两个引用，也就是地址是否相等。
   - 在 Java 中">"和"<" 只能判断数字型，对于 Integer 包装类型，是根据 intValue() 方法的返回值进行比较的。

8. 优先使用整型池

   - valueOf 方法和 Integer i = 3；然后 i ==j ;的方法是一样的。

   Integer.valueOf 的实现代码

   ```java
   final int offset = 128;
   if(i >= -128 && i<= 127){must cache
     return IntegerCache.cache[i+offset];
   }
   return new Integer(i);
   ```

   - 因此在声明包装对象的时候使用 valueOf 生成`i = Integer.valueOf(88)`，而不是通过构造函数生成`Integer i = new Integer(88)`。
   - 在判断对象是否相等的时候，最好是用 equals 方法，避免使用" == "产生非预期结果。

9. 优先选择基本类型

   - 整个 f(Integer.valueOf(i)) 的执行过程：
     - i 通过 valueOf 方法包装成一个 Integer 对象。
     - 由于没有 f(Integer i) 方法，编译器把 Integer 对象转换成 int。
     - int 自动拓宽成 long  ，找到了 f(long i) 方法。

10. 不要随便设置随机种子

  - 种子不同，产生不同随机数。
  - 种子相同，即使实例不同也产生相同的随机数。

#### 第三章、类、对象及方法

31. 在接口中不要存在实现代码
    - 如果把实现代码写到接口中，那接口就绑定了可能变化的因素，就会导致实现不再稳定可靠，是随时都有可能被抛弃、更改和重构的。


31. 静态变量一定要先声明后赋值
    - 因为静态变量是在类初始化的时候首先被加载的，JVM 会去查找类中所有静态声明，然后分配空间，但注意，这时候只是完成了地址空间的分配，还没有赋值。之后会根据类中静态赋值的先后顺序执行。
    - 所以一定要先声明后赋值，不然可能得到的结果和你所期望的不一样。
32. 不要覆写静态方法
    - 在子类中构建与父类相同的方法名、输入参数、输出参数、访问权限